{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"training_cookbook/","title":"Training Cookbook","text":"<p>Traditionally, machine learning codebases rely on libraries to perform much of the bookkeeping and parameter wrangling necessary for training large, complex models. While convenient, these libraries can abstract the key functionality and core APIs offered in JAX. The purpose of this cookbook, therefore, is to demonstrate best practices (or \"recipes\") for writing simple yet high-performance machine learning training code directly in JAX. Following the patterns documented below will prepare your machine learning workloads to maximally leverage our compiler (XLA) for performance and tractability.</p> <p>Most training scripts adhere roughly to the following structure: <pre><code>def train_loop(config: Config):\n  record_writer = RecordWriter()\n  train_state = init_train_state(config)\n  train_state = jax.tree.map(mutable_array, train_state)\n  batch = iter(get_dataset_on_device(config))\n  for step in range(config.num_train_steps):\n    metrics = train_step(config, train_state, next(batch))\n    record_writer({\"step\": step} | metrics)\n</code></pre> For each line of code above, we will explain the best practices and showcase the core technologies we have assembled to empower you to write simple, yet unbelievably performant code in JAX. The code above is a segment of a self-contained, completely functional companion script in which we initialize a Vaswani et al. (2017) Transformer decoder and define the training loss for next-token prediction in pure JAX. The code therein is suited to TPUs, CPUs, and GPUs, as well as single- and multi-host systems. For that reason, we use the terms device or accelerator to refer interchangeably to the hardware JAX is primarily performing arithmetic on\u2014whether it be a TPU, GPU, or CPU\u2014and host system to refer to operations performed exclusively using the host CPU.</p> <p>In this guide, there are many aspects of the JAX APIs we will gloss over for the sake of expediency. These are available for you to peruse at your leisure in our API documentation. However, there is a central JAX concept that one must confront in detail for much of what follows to cohere.</p>"},{"location":"training_cookbook/#device-mesh-and-shardings","title":"Device Mesh and Shardings","text":"<p>JAX employs the Single Program, Multiple Data (SPMD) model of parallelism. This means we write a single program that runs on multiple devices, using annotations to specify which part of the data each device is responsible for. The two primary concepts for this are the <code>Mesh</code> and the <code>PartitionSpec</code>.</p>"},{"location":"training_cookbook/#device-mesh","title":"Device Mesh","text":"<p>A <code>jax.sharding.Mesh</code> is an arrangement of all our accelerators into a NumPy <code>ndarray</code>, together with string labels for the axes of the device array. The reason for using an array is that this allows for a very convenient annotation for how arrays should be partitioned across devices. For this introduction, we will use the notation of an ordered dictionary<sup>1</sup>, so that <code>{\"x\": 2, \"y\": 4}</code> refers to a device mesh of shape <code>(2, 4)</code> with labeled axes <code>\"x\"</code> and <code>\"y\"</code>. To shard an array <code>param</code>, we decorate it with a <code>PartitionSpec</code>, which is a tuple of <code>str | None</code> elements of the same length as the dimensions of the array. The <code>PartitionSpec</code> specifies which axes of our array are to be sharded over which axes of devices. A more thorough account of the notation of shardings and sharded computations is available in our sharding tutorial. Some common sharding strategies such as data parallel, fully sharded data parallel, and basic tensor parallelism will be covered in Achieving High Performance.</p> <p>Example</p> <p>Suppose we have a device mesh of <code>{\"x\": 2, \"y\": 4}</code> and an array <code>param</code> of shape <code>(32, 64, 64, 128)</code>. If we shard this array with <code>PartitionSpec(None, \"x\", \"y\", None, None)</code>, we end up with shards of size <code>(32, 32, 16, 128)</code> distributed across the devices. The <code>None</code> indicates that an axis should not be sharded. JAX implicitly broadcasts trailing axes, so an identical sharding can be achieved more concisely with <code>PartitionSpec(None, \"x\", \"y\")</code>. As a result, the shorthand for a fully replicated array (of any dimension) is <code>PartitionSpec()</code>.</p> <p>Example</p> <p>More advanced mesh geometries are convenient when aligned with the communication hierarchy of our devices. Host-to-host communication is typically slower than accelerator-to-accelerator communication. Suppose we have two host machines, each with eight attached GPUs. One might arrange the devices into a mesh of <code>{\"host\": 2, \"gpu\": 8}</code>. Then we can shard a parameter as follows: <pre><code>param = jnp.zeros((256, 192), device=PartitionSpec(\"gpu\", None))\n</code></pre> The whole of <code>param</code> will be replicated twice, but within each host, it will be spread across the eight locally attached GPUs, with each GPU storing a shard of shape <code>(32, 192)</code> in HBM. This is particularly useful for FSDP sharding.</p>"},{"location":"training_cookbook/#train-state-initialization","title":"Train State Initialization","text":"<p><pre><code>@jax.jit\ndef init_train_state(config: Config) -&gt; dot_dict:\n  train_state = dot_dict()\n  train_state.params = init_param_state(config)\n  train_state.opt = jax.tree.map(init_adam_state, train_state.params)\n  return train_state\n</code></pre> Before we can get started, the first thing we need to do is set up the train state. The train state encapsulates (unsurprisingly) all the stateful aspects of the training process. This typically includes, at a minimum, the model parameters and the optimizer state. The way we have structured this function (though you may choose to do otherwise) is to:</p> <ol> <li> <p>Create a series of nested dictionaries to house the model parameters, and then</p> </li> <li> <p><code>jax.tree.map</code> over those parameters to produce a similar set of nested dictionaries to house the accompanying optimizer states. (More on this below.)</p> </li> </ol>"},{"location":"training_cookbook/#parameter-initialization","title":"Parameter Initialization","text":"<p><pre><code>@jax.jit\ndef init_train_state(config: Config) -&gt; dot_dict:\n  train_state = dot_dict()\n  train_state.params = init_param_state(config)\n  train_state.opt = jax.tree.map(init_adam_state, train_state.params)\n  return train_state\n</code></pre> To initialize our parameters, we build a series of nested dictionaries that correspond to the semantic sections of the neural network. If we were using a layer-based library such as PyTorch or Flax, these might correspond to neural network layers. For this example, we could, in fact, get by with a completely flattened dictionary, but the nested approach is convenient both for working with some of the APIs in JAX and for structuring our code.</p> <p><pre><code>def init_param_state(config: Config) -&gt; dot_dict:\n  root_key = jax.random.key(config.param_seed)\n  key = map(ft.partial(jax.random.fold_in, root_key), it.count())\n  zero_init = jax.nn.initializers.constant(0.0)\n  he_init = jax.nn.initializers.he_normal(1, 1)\n  dtype = config.dtype\n\n  params = dot_dict(\n    pos_embed=zero_init(next(key), (config.seq_length, config.embed_dim), dtype, config.pos_embed),\n    layers=dot_dict(),\n  )\n  params.embedding = he_init(next(key), (config.vocab_size, config.embed_dim), dtype, config.embed)\n  params.linear_in = dot_dict(\n    kernel=he_init(next(key), (1, config.embed_dim), dtype, config.in_kernel),\n    bias=zero_init(next(key), (config.embed_dim,), dtype, config.in_bias),\n  )\n  params.linear_out = dot_dict(\n    kernel=he_init(next(key), (config.embed_dim, config.vocab_size), dtype, config.out_kernel),\n  )\n  for layer in range(config.num_layers):\n    qkv_shape = (3, config.embed_dim, config.num_heads, config.head_dim)\n    out_shape = (config.num_heads, config.head_dim, config.embed_dim)\n    params.layers[layer] = dot_dict(\n      attention=dot_dict(\n        qkv=he_init(next(key), qkv_shape, dtype, config.att_qkv),\n        out=he_init(next(key), out_shape, dtype, config.att_out),\n      ),\n      mlp=dot_dict(\n        in_kernel=he_init(next(key), (config.embed_dim, config.mlp_dim), dtype, config.mlp_in),\n        out_kernel=he_init(next(key), (config.mlp_dim, config.embed_dim), dtype, config.mlp_out),\n      ),\n    )\n  return params\n</code></pre> Our <code>get_param_state</code> function makes use of the <code>constant</code> and <code>he_normal</code> factories provided in <code>jax.nn.initializers</code>. These factories return an initializer, which is a function conforming to the following protocol: <pre><code>class Initializer(Protocol):\n    def __call__(self, key, shape, dtype, out_sharding) -&gt; jax.Array:\n        ...\n</code></pre> The functional flavor of JAX requires explicit handling of all stochasticity, so we set up a little iterator that yields PRNG keys. Then, to build our parameters, we initialize them at their respective positions in the <code>params</code> nested dictionary, supplying the parameter shape, dtype, and sharding from the <code>Config</code> class.</p> <p>Note</p> <p>By specifying the shardings here, we initialize each shard of each parameter directly on the correct device in the device mesh where it needs to be, preventing the need for needless host-to-device transfers or, in the case of a model that does not fit in system memory, avoiding out-of-memory errors.</p>"},{"location":"training_cookbook/#optimizer-initialization","title":"Optimizer Initialization","text":"<p><pre><code>@jax.jit\ndef init_train_state(config: Config) -&gt; dot_dict:\n  train_state = dot_dict()\n  train_state.params = init_param_state(config)\n  train_state.opt = jax.tree.map(init_adam_state, train_state.params)\n  return train_state\n</code></pre> When it comes to setting up the optimizer state, things are a little less straightforward than when we built the model parameters. The Adam optimizer requires that, for each parameter, we keep track of three optimization states: <code>mu</code>, <code>nu</code>, and <code>count</code>. The simplest of these is <code>count</code>, which stores the number of training steps we have performed. This is just a scalar used to de-bias the Adam updates. The <code>mu</code> and <code>nu</code> states will be arrays of the same shape, dtype, and sharding as the accompanying parameter <code>param</code>.<sup>2</sup> <pre><code>def init_adam_state(param: jax.Array) -&gt; dot_dict:\n  adam_state = dot_dict(mu=jnp.zeros_like(param), nu=jnp.zeros_like(param), count=jnp.array(0))\n  return adam_state\n</code></pre> When we use <code>jax.tree.map</code>, it iterates over the items in <code>train_state.params</code>. For each parameter, it creates a corresponding Adam state, resulting in a new nested dictionary that mirrors the structure of <code>train_state.params</code>. Each leaf in this new structure contains the optimizer state for the corresponding parameter.</p>"},{"location":"training_cookbook/#the-train-step-functional-transformations","title":"The Train Step (Functional Transformations)","text":"<p><pre><code>@jax.jit\ndef train_step(config: Config, train_state: dot_dict, batch: dict) -&gt; dict:\n  def loss_fn(params):\n    logits = model_apply(config, params, batch[\"observed_ids\"])\n    labels = jax.nn.one_hot(batch[\"target_ids\"], config.vocab_size)\n    return -(labels * jax.nn.log_softmax(logits)).mean()\n\n  params = jax.tree.map(op.methodcaller(\"get\"), train_state.params)\n  loss, grad = jax.value_and_grad(loss_fn)(params)\n  jax.tree.map(ft.partial(adam_update, config), train_state.params, grad, train_state.opt)\n  metrics = {\"train_loss\": loss}\n  return metrics\n</code></pre> The train step is where we calculate the gradient of the model with respect to the current parameters and use the gradient, together with the optimizer, to update the parameters. To do this in JAX, we define the forward pass of the model, then we leverage JAX's functional transformations to automatically generate the backward pass, which we use to calculate the gradients and perform the update.</p>"},{"location":"training_cookbook/#model-forward-pass","title":"Model Forward Pass","text":"<p><pre><code>def model_apply(config: Config, params: dot_dict, tokens: jax.Array) -&gt; jax.Array:\n  out = params.embedding.at[tokens].get(out_sharding=config.act_seq)\n  out += params.pos_embed\n  del tokens\n\n  for layer in range(config.num_layers):\n    block = params.layers[layer]\n    att_skip = out  # 1 billion dollars in venture capital funding please\n    qkv = jnp.einsum(\"bsd,3dkh-&gt;bs3kh\", out, block.attention.qkv, out_sharding=config.act_att)\n    out = jax.nn.dot_product_attention(qkv[:, :, 0, :], qkv[:, :, 1, :], qkv[:, :, 2, :], is_causal=True)\n    out = jnp.einsum(\"bskh,khd-&gt;bsd\", out, block.attention.out, out_sharding=config.act_seq)\n    out += att_skip\n    out *= jax.lax.rsqrt(jnp.linalg.norm(out, axis=-1, keepdims=True) + 1e-6)\n\n    mlp_skip = out  # machine learning circa 1986\n    out = jnp.einsum(\"bsd,dh-&gt;bsh\", out, block.mlp.in_kernel, out_sharding=config.act_hidden)\n    out = jax.nn.gelu(out)\n    out = jnp.einsum(\"bsh,hd-&gt;bsd\", out, block.mlp.out_kernel, out_sharding=config.act_seq)\n    out += mlp_skip\n    out *= jax.lax.rsqrt(jnp.linalg.norm(out, axis=-1, keepdims=True) + 1e-6)\n\n  logits = jnp.einsum(\"bsd,dl-&gt;bsl\", out, params.linear_out.kernel, out_sharding=config.act_seq)\n  return logits\n</code></pre> The model's forward pass is mostly unremarkable, aside from the <code>out_sharding</code> annotations we have supplied. These annotations declare what the result-sharding should be after the operation executes. The compiler uses these activation shardings, together with the parameter shardings we supplied when we initialized the model, to dynamically insert communication collectives that ferry parameters and activations alike between devices.</p> <p>By choosing a good sharding strategy, we can achieve highly performant training (and inference) code. We will cover some standard strategies that serve most use cases in the section titled Achieving High Performance. For a detailed discussion of the principles underpinning the design of sharding strategies, see The Scaling Cookbook.</p>"},{"location":"training_cookbook/#gradient-and-optimizer-update","title":"Gradient and Optimizer Update","text":"<p><pre><code>@jax.jit\ndef train_step(config: Config, train_state: dot_dict, batch: dict) -&gt; dict:\n  def loss_fn(params):\n    logits = model_apply(config, params, batch[\"observed_ids\"])\n    labels = jax.nn.one_hot(batch[\"target_ids\"], config.vocab_size)\n    return -(labels * jax.nn.log_softmax(logits)).mean()\n\n  params = jax.tree.map(op.methodcaller(\"get\"), train_state.params)\n  loss, grad = jax.value_and_grad(loss_fn)(params)\n  jax.tree.map(ft.partial(adam_update, config), train_state.params, grad, train_state.opt)\n  metrics = {\"train_loss\": loss}\n  return metrics\n</code></pre> In order to calculate the gradient, we define the training loss. This is a function of the parameters that returns a scalar which summarizes how well our model, with the current <code>train_state</code> parameters, is explaining the data. <pre><code>loss, grad = jax.value_and_grad(loss_fn)(params)\n</code></pre> By supplying this function to <code>jax.value_and_grad</code>, we transform it into a function that returns both the scalar value and the gradient of <code>loss_fn</code> evaluated at <code>params</code> (the value and grad).</p> <p>Since we have defined our parameters in terms of a series of nested dictionaries, the gradient will also be a series of nested dictionaries, mirroring the parameters. Recall that, unlike the parameters, the optimizer states contain some extra, deeper nested dictionaries corresponding to the optimizer state per parameter. Take a moment, before reading the explanation, to ponder what the semantics of the following function call might be: <pre><code>jax.tree.map(ft.partial(adam_update, config), train_state.params, grad, train_state.opt)\n</code></pre> Examining the call signature of the function <code>adam_apply</code> gives us a hint: <pre><code>def adam_update(config: Config, param: jax.Array, grad: jax.Array, adam_state: dot_dict):\n  adam_state.mu[...] = (1 - config.beta_1) * adam_state.mu[...] + config.beta_1 * grad\n  adam_state.nu[...] = (1 - config.beta_2) * adam_state.nu[...] + config.beta_2 * grad**2\n  adam_state.count[...] += 1\n\n  mu_hat = adam_state.mu[...] / (1 - config.beta_1 ** adam_state.count[...])\n  nu_hat = adam_state.nu[...] / (1 - config.beta_2 ** adam_state.count[...])\n  param[...] -= config.learning_rate * mu_hat / (jnp.sqrt(nu_hat + config.eps_root) + config.eps)\n</code></pre> Because <code>train_state.params</code> is the first argument, <code>jax.tree.map</code> uses its tree structure to guide the mapping process.<sup>3</sup> This means that <code>train_state.opt</code> is traversed only as deep as the leaves of <code>train_state.params</code>. The optimizer state for each parameter is therefore passed in as a complete subtree, which allows us to easily access all relevant states (like <code>mu</code> and <code>nu</code>) for a given <code>param</code> inside <code>adam_apply</code>.</p> <p>Tip</p> <p>If we wished to use different optimization algorithms and states on different parameters in our model (or freeze some parameters), we could achieve this by modifying the body of <code>adam_apply</code> and replacing <code>jax.tree.map</code> with <code>jax.tree_util.tree_map_with_path</code>, which allows the operand function to customize its behavior depending on the parameter.</p>"},{"location":"training_cookbook/#the-training-loop","title":"The Training Loop","text":"<pre><code>def train_loop(config: Config):\n  record_writer = RecordWriter()\n  train_state = init_train_state(config)\n  train_state = jax.tree.map(mutable_array, train_state)\n  batch = iter(get_dataset_on_device(config))\n  for step in range(config.num_train_steps):\n    metrics = train_step(config, train_state, next(batch))\n    record_writer({\"step\": step} | metrics)\n</code></pre> <p>During training, we have to orchestrate the flow of data between two key players: the host system and the accelerator. Ensuring smooth interplay between these systems is key to writing highly performant training code. The Python GIL would ordinarily pose a significant obstacle here, but to work around this, the paradigm of Asynchronous Dispatch adopted by JAX makes this orchestration easy to accomplish. But, in order to leverage this paradigm, we need to be mindful of how our code will be executed when structuring our training step.</p>"},{"location":"training_cookbook/#efficiency-via-asynchronous-dispatch","title":"Efficiency via Asynchronous Dispatch","text":"<p>One of the most important tasks performed by the host system is to fetch data and place it on the accelerators so that the accelerators are never waiting for data. The time when accelerators are waiting idle between train steps is referred to as the step bubble. We can leverage asynchronous dispatch to minimize the step bubble. Let's see how this works with our training loop, discarding, for the moment, the line concerning the <code>record_writer</code>. <pre><code>metrics = train_step(config, train_state, next(batch))\n</code></pre> When this code executes, Python will first query the range iterator, get <code>step</code> (with value <code>0</code>), then call <code>next(batch)</code>, which will take some time to retrieve the batch. Then, <code>train_step</code> gets called. So far, nothing out of the ordinary.</p> <p>What happens next is interesting. Because <code>jax.jit</code>-decorated calls are non-blocking, the call to <code>train_step</code> returns to the Python interpreter immediately. While the computation is enqueued on the accelerator, no work is actually performed yet. The Python loop continues, advancing the step counter and calling <code>next(batch)</code> for the next iteration.</p> <p>Once the second call to <code>train_step</code> is made, its inputs are now the mutated reference to <code>train_state</code> from the previous JIT call and a fresh batch of data. The runtime is clever and sees that in order to execute the second call to <code>train_step</code>, we first need to realize the <code>train_state</code> result of step <code>0</code> to perform the mutation. And so it fires off the computation for the first step, and, crucially, while this happens, <code>train_step</code>, once again, returns immediately, and the loop skips over again. Python now runs ahead until it encounters the <code>next(batch)</code> function at step 3, which proceeds to execute in Python, loading data, while the first train step is executing (for real this time). And just like that, we can simultaneously load data and perform math on the accelerator, without any traditional multiprocessing.<sup>4</sup></p> <pre><code>---\ndisplayMode: compact\n---\ngantt\n    title Synchronous Dispatch: No Overlap\n    axisFormat %\n\n    section Host\n    next(batch) 0 :gb0, 0, 1000s\n    next(batch) 1 :gb1, after ajc0, 1000s\n    next(batch) 2 :gb2, after ajc1, 1000s\n\n    section Accelerator\n    train_step 0 :ajc0, after gb0, 2000s\n    train_step 1 :ajc1, after gb1, 2000s</code></pre> <pre><code>---\ndisplayMode: compact\n---\ngantt\n    title JAX Asynchronous Dispatch: Host-Device Overlap\n    axisFormat %\n\n    section Host\n    %% Task: id, name, start, duration_or_end\n    next(batch) 0 :gb0, 0, 1000s\n    next(batch) 1 :gb1, after gb0, 1000s\n    next(batch) 2 :gb2, after gb1, 1000s\n    next(batch) 3 :gb3, after jc0, 1000s\n    next(batch) 4 :gb4, after jc1, 1000s\n\n    section Accelerator\n    %% Task: id, name, start, duration_or_end\n    train_step 0 :jc0, after gb1, 2000s\n    train_step 1 :jc1, after jc0, 2000s\n    train_step 2 :jc2, after jc1, 2000s</code></pre>"},{"location":"training_cookbook/#common-mistakes","title":"Common Mistakes","text":"<p>When writing asynchronous dispatch code in Python, there are two primary mistakes one should be wary of so as not to interrupt our careful orchestration of compute.</p>"},{"location":"training_cookbook/#requesting-device-to-host-transfers","title":"Requesting device-to-host transfers","text":"<p>Up until now, we have ignored what happens to the variable <code>metrics</code>. Indeed, if this is left dangling, nothing will happen, and we will achieve good overlap just as advertised. However, more often than not, we would like to observe telemetry from our train step, such as the current loss, gradient statistics, and so on. Suppose we were to insert code such as: <pre><code>metrics = train_step(config, train_state, next(batch))\nprint({\"step\": step} | metrics)\n</code></pre> Instead of the loop ticking over, <code>print</code> will incur a device-to-host transfer of whatever on-device arrays are in <code>metrics</code>. This interrupts the Python interpreter, and the code is forced to execute synchronously, producing a step bubble. The solution is slightly counterintuitive: at each step, we gather the telemetry for the previous step. <pre><code>class RecordWriter:\n  prev_metrics = None\n\n  def __call__(self, cur_metrics: dict):\n    self.prev_metrics, log_metrics = cur_metrics, self.prev_metrics\n    if log_metrics is None:\n      return\n    print(*it.starmap(\"{}: {}\".format, log_metrics.items()), sep=\"\\t\")\n</code></pre> and <pre><code>metrics = train_step(config, train_state, next(batch))\n</code></pre> A small helper function like this is essential to achieve good overlap and make the most of the resources of our host system and our accelerator. Of course, the simple <code>print</code> statement here can be swapped out for any Python operation that requests data from the accelerator.</p>"},{"location":"training_cookbook/#interrupting-the-accelerator","title":"Interrupting the accelerator","text":"<p>The other common way in which we can waste spectacular amounts of cloud compute money is by unintentionally enqueuing math operations on the accelerator outside of the train step. Suppose we are using a cosine learning rate schedule. <pre><code>def learning_rate(count, init_value: float = 1e-4, decay_steps: int = 10_000, alpha: float = 1e-6):\n    cosine_decay = 0.5 * (1 + jnp.cos(jnp.pi * jnp.minimum(count, decay_steps) / decay_steps))\n    return init_value * (1 - alpha) * cosine_decay\n</code></pre> A common pattern is to want to visualize the schedule alongside the other metrics we're gathering. However, even if we use the clever <code>record_writer</code> class we defined earlier, the following code will create a bubble on the accelerator. <pre><code>metrics = train_step(config, train_state, next(batch))\nrecord_writer({\"step\": step, \"learning_rate\": learning_rate(step)} | metrics)\n</code></pre> This is because we have used <code>jax.numpy</code> in our calculations. When <code>jnp.minimum</code> is called, the Python integer <code>step</code> is promoted to a <code>jax.Array</code> and transferred to the accelerator (a host-to-device transfer). The calculation is now enqueued on the accelerator, outside our main <code>train_step</code>. To <code>print</code> the result, the value must be transferred back to the host (a device-to-host transfer). This round-trip forces the accelerator to synchronize with the host, and we have thrown away money by creating a performance bubble.</p> <p>The two ways to avoid this are to use NumPy for these calculations or to use the <code>jax.default_device</code> context manager. <pre><code>metrics = train_step(config, train_state, next(batch))\nwith jax.default_device('cpu'):\n  record_writer({\"step\": step, \"learning_rate\": learning_rate(step)} | metrics)\n</code></pre></p>"},{"location":"training_cookbook/#data-loading","title":"Data Loading","text":"<p>In addition to overlapping the actual loading of the data (that is, retrieving it from network storage to the host), JAX also allows us to overlap the host-to-device transfer of the data itself with the computation of the train step. The special function <code>jax.device_put</code> is carefully designed to be non-blocking, executing asynchronously, which makes it perfectly fine to use in the context of our train step. However, there is a more convenient function specifically designed for the task of loading data.</p> <p>In the following code, <code>dataset</code> is an ordinary Python iterator that yields a <code>dict</code> of batched data. By mapping over this iterator with <code>jax.make_array_from_process_local_data</code>, we generate a new iterator. Yielding from this new iterator will generate data placed on the device, ready for consumption by our train step. Internally, it will <code>jax.tree.map</code> to create <code>jax.Array</code> objects and queue them to be transferred to the device. Provided the data can be batched fast enough, on both TPUs and GPUs, these transfers will be overlapped with the train step computation. <pre><code>def get_dataset_on_device(config: Config) -&gt; Iterator[dict[str, jax.Array]]:\n  datset = get_dataset(config)\n  sharding = jax.P(config.mesh_axis_names)\n  return map(ft.partial(jax.make_array_from_process_local_data, sharding), datset)\n</code></pre></p>"},{"location":"training_cookbook/#achieving-high-performance","title":"Achieving High Performance","text":"<p>In this section, we will describe the three primary forms of model parallelism that are useful for training. During training, throughput is of paramount importance; that is, we wish to maximize the average number of operations per second. This contrasts with inference, where the goal is to minimize latency by ensuring all the operations happen in as little time as possible. Keeping throughput in mind as our ultimate goal for training, this section introduces the three primary strategies for sharding during training. For each strategy, we outline the JAX shardings that implement it and describe the collectives involved so that when studying program traces, you'll have landmarks to look for to confirm that the program is behaving as expected. The sharding variables we define in the code blocks below correspond to their uses in the initialization and model forward pass.</p>"},{"location":"training_cookbook/#data-parallel","title":"Data Parallel","text":"<p>Data parallel is the most common and easy-to-understand form of parallelism. In this scheme, each accelerator stores a complete copy of the model parameters, and we shard activations along the batch axis to split the computation of the gradients. To compute the gradients, each accelerator performs an individual forward and backward pass. Then, before the parameters are updated, XLA inserts an <code>AllReduce</code> to share the updates and keep the models in sync.</p> <p>Mesh<pre><code>mesh = jax.sharding.Mesh(jax.devices(), ('devices',))\n</code></pre> Parameter Shardings<pre><code>pos_embed = PartitionSpec(None, None)\natt_qkv = PartitionSpec(None, None, None, None)\natt_out = PartitionSpec(None, None, None)\nmlp_in = PartitionSpec(None, None)\nmlp_out = PartitionSpec(None, None)\nin_kernel = PartitionSpec(None, None)\nin_bias = PartitionSpec(None)\nout_kernel = PartitionSpec(None, None)\nout_bias = PartitionSpec(None)\n</code></pre> Activation Shardings<pre><code>act_ids = PartitionSpec(\"devices\")\nact_seq = PartitionSpec(\"devices\", None, None)\nact_att = PartitionSpec(\"devices\", None, None, None)\nact_hidden = PartitionSpec(\"devices\", None, None)\n``\n\n### Fully-Sharded Data Parallel (FSDP)\nThe drawback of data-parallel sharding is that we have to keep multiple, full, redundant copies of the model parameters in HBM. This is a very performant strategy for small models, but since HBM is in short supply, we need to shard the model parameters as well. In the *Fully-Sharded Data Parallel (FSDP)* strategy, we shard both the model and the parameters.\n\nNow, as the forward pass happens, the parameters are, one-by-one, unsharded (via [`AllGather`](https://openxla.org/xla/operation_semantics#allgather)) into whole arrays before they are applied to the activations. This unsharding is brief and temporary, however, leading to a large saving in HBM. In the backward pass, each `AllGather` becomes a `ReduceScatter`. Then there is a final `ReduceScatter` at the optimizer update to synchronize gradients. Compared with Data parallelism, the total communication traffic is 50% highter, but we our HBM pressure is reduced by the size of the model divided by the number of devices.  \n\n```python {title=\"Mesh\"}\nmesh = jax.sharding.Mesh(jax.devices(), ('fsdp',))\n</code></pre> Parameter Shardings<pre><code>pos_embed = PartitionSpec(None, None)\natt_qkv = PartitionSpec(None, \"fsdp\", None, None)\natt_out = PartitionSpec(\"fsdp\", None, None)\nmlp_in = PartitionSpec(\"fsdp\", None)\nmlp_out = PartitionSpec(None, \"fsdp\")\nin_kernel = PartitionSpec(None, None)\nin_bias = PartitionSpec(None)\nout_kernel = PartitionSpec(\"fsdp\", None)\nout_bias = PartitionSpec(None)\n</code></pre> Activation Shardings<pre><code>act_ids = PartitionSpec(\"fsdp\")\nact_seq = PartitionSpec(\"fsdp\", None, None)\nact_att = PartitionSpec(\"fsdp\", None, None, None)\nact_hidden = PartitionSpec(\"fsdp\", None, None)\n</code></pre></p> <p>Note</p> <p>While FSDP entails a great deal more communication than data parallel, in practice we are able to overlap the communication with the compute, thereby hiding it and achieving the same throughput at a drastically improved HBM budget.</p> <p>TODO: Mention specific flags to enable this for TPUs vs GPUs. On TPUs it's the async all-gather and reduce-scatter functionality. On GPUs, you have to set threshold values as specified in the NVIDIA JAX-Toolbox repository.</p>"},{"location":"training_cookbook/#tensor-parallel","title":"Tensor Parallel","text":"<p>If our model is large enough and structured appropriately, it becomes beneficial to partition the computation within a single example across our accelerators. Using a matrix multiplication as an example, we can spread the large matrix multiplications over two or four accelerators. This entails significantly more communication, and so this strategy only works for computations with a very high arithmetic intensity, such as extremely large matrix multiplications.</p> <p>With multi-head self-attention, we opt to shard along the heads with a replicated sequence axis, since this offers the most natural amount of parallelism. If the MLP is large enough we can also efficiently shard the matrix multiplications.</p> <p>Mesh<pre><code>mesh = jax.sharding.Mesh(np.array(jax.devices()).reshape(128, 4), (\"fsdp\", \"tensor\"))\n</code></pre> Parameter Shardings<pre><code>pos_embed = PartitionSpec(None, \"tensor\")\natt_qkv = PartitionSpec(None, \"fsdp\", \"tensor\", None)\natt_out = PartitionSpec(\"fsdp\", None, None)\nmlp_in = PartitionSpec(\"fsdp\", \"tensor\")\nmlp_out = PartitionSpec(\"tensor\", \"fsdp\")\nin_kernel = PartitionSpec(None, None)\nin_bias = PartitionSpec(None)\nout_kernel = PartitionSpec(\"fsdp\", None)\nout_bias = PartitionSpec(None)\n</code></pre> Activation Shardings<pre><code>act_ids = PartitionSpec(\"fsdp\")\nact_seq = PartitionSpec(\"fsdp\", None, None)\nact_att = PartitionSpec(\"fsdp\", None, \"tensor\", None)\nact_hidden = PartitionSpec(\"fsdp\", None, \"tensor\")\n</code></pre></p> <ol> <li> <p>Of course, all dictionaries are order-preserving in modern Python, so this is somewhat redundant.\u00a0\u21a9</p> </li> <li> <p>This is accomplished by using the <code>zeros_like</code> constructor, but we could have specified the sharding manually using the <code>devices</code> argument of many of the <code>jax.numpy</code> functions.\u00a0\u21a9</p> </li> <li> <p>We could have achieved the same behavior equivalently by ordering <code>grad</code> first.\u00a0\u21a9</p> </li> <li> <p>For the purposes of this explanation, you can think of <code>next(batch)</code> as just a sleep.\u00a0\u21a9</p> </li> </ol>"}]}